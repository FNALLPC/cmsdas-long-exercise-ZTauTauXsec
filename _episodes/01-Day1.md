---
title: "Exercise 1"
# teaching: 0
# exercises: 0
# questions:
# - "Key question (FIXME)"
# objectives:
# - "First learning objective. (FIXME)"
# keypoints:
# - "First key point. Brief Answer to questions. (FIXME)"
---
# Selecting a final state and trigger

Choose one of the three $\tau \tau$ final states with at least one hadronically decaying $\tau$. Of the final states we are considering, there are two options for choice of trigger. (Slide 5 of the intro slides). We need to decide which is best for our analysis.

- For the $\mu+\tau_h$ channel consider :
    <ol type="a">
    <li>The single isolated muon. </li>
    <li>The trigger requiring a single muon and single $\tau_h$.</li>
    </ol>
- For the $e+\tau_h$ channel consider :
    <ol type="a">
    <li>The single electron trigger. </li>
    <li>The trigger requiring a single electron and single $\tau_h$.</li>
    </ol>
- For the $\tau_h+\tau_h$ channel consider :
    <ol type="a">
    <li>The trigger requiring two $\tau_h$. </li>
    <li>The trigger requiring a single $\tau_h$ (of large $p_T$)</li>
    </ol>

The available list of all triggers in NANOAOD can be found in the [NANOAOD documentation](https://cms-nanoaod-integration.web.cern.ch/integration/master-102X/mc102X_doc.html#HLT).

To learn to write Python code and use the [NanoAODTools](https://twiki.cern.ch/twiki/bin/view/CMS/NanoAODTools) framework, we will start with [`exampleAnalysis.py`](https://github.com/fojensen/nanoAOD-tools/blob/cmsdas2022/python/postprocessing/examples/exampleAnalysis.py) as a template. To run the example:

```shell
cd ${CMSSW_BASE}/src/PhysicsTools/NanoAODTools/analysis/
python ${CMSSW_BASE}/src/PhysicsTools/NanoAODTools/python/postprocessing/examples/exampleAnalysis.py
```
This **example** selects events from the input file and applies a preselection choosing events with at least one jet of pt > 250 GeV. It then loops over these events, selects those with at least 2 muons, and creates the Lorentzvector sum of the electrons, muons, and jets in the event. A histogram is then filled with the $p_T$ of the vector. An additional example of the syntax (c++) for preselection can be found [here](https://github.com/fojensen/nanoAOD-tools/blob/cmsdas2022/crab/crab_script.py#L40-L54). Although for our purposes feel free to not use any at all.

You may view the histogram using the root TBrowser:

```
root histOut.root
TBrowser b
```

The input file is a TTJets MC sample, but you will need to switch that to a DY (Z) MC sample. Use the file found here:

```
eosls -alh /store/user/cmsdas/2022/short_exercises/Tau/DYJetsToLL__7B7D90CB-14EF-B749-B4D7-7C413FE3CCC1.root
```

Which can be accessed in the following manner:

```
root://cmseos.fnal.gov//store/user/cmsdas/2022/short_exercises/Tau/DYJetsToLL__7B7D90CB-14EF-B749-B4D7-7C413FE3CCC1.root
```

We need to calculate the signal efficiency for each of the two trigger options. To do so, you need to loop over all the entries in a signal MC file using the template provided.

- As we are only interested in the events for your particular final state, You need to select those events in which the Z boson decays into a pair of tau leptons, which each then subsequently decay into your particular final state. For example in the $\mu+\tau_h$ channel, you will want your "denominator" events to be those in which there is exactly 1 reconstructed muon (gen-matched to a muon from a tau decay) and 1 reconstructed tauh (gen-matched to a hadronic tau decay); apply no further selection to the reconstructed particles. The Tau_genPartFlav and Muon_genPartFlav variables in the [NANOAOD documentation](https://cms-nanoaod-integration.web.cern.ch/integration/master-102X/mc102X_doc.html) have information about the gen matching which you can use in your loops.

- Once the denominator events are selected, you then determine the numerator events: the events must pass your trigger, the particles must satisfy baseline ID requirements (e.g. anti-e, anti-mu and anti-jet tagging for the $\tau_h$, the particles must pass the additional kinematic (pt and eta) requirements dictated within the trigger name. The triggers are booleans: pass or not pass.


Although in c++, examples of event loops used in the [Tau Short Exercise](https://twiki.cern.ch/twiki/bin/view/CMS/SWGuideCMSDataAnalysisSchoolLPC2022TauShortExercise) can be found in [eff.c](https://github.com/fojensen/nanoAOD-tools/blob/cmsdas2022/analysis/eff.c#L61-L87) and [taumdm.c](https://github.com/fojensen/nanoAOD-tools/blob/cmsdas2022/analysis/taumdm.c#L155-L185).

For analysis, the reconstructed objects (muons, electrons, taus) need additional identification quality criteria:

- Muons:
    - A cut requiring $ \|\eta\| < 2.4 $ . This is maximum extent in the eta coordinates of the muon detectors.
    - Muon_tightId, or Muon_mediumId. This ensures you have a quality muon. Choose one.
    - The muon isolation variable is named Muon_pfIsoId. This needs to be applied if considering the isolated muon triggers.
    - <https://twiki.cern.ch/CMS/SWGuideMuonIdRun2>
- Electrons:
    - A cut requiring $\|\eta\|<2.5$. This is the maximum extent in the eta coordinates of the silicon tracker.
    - `Electron_mvaFall17V2Iso_WP80`, `Electron_mvaFall17V2Iso_WP90`. This ensures a quality electron. Choose one.
    - <https://twiki.cern.ch/CMS/EgammaIDRecipesRun2>
- Taus:
    - A cut requiring $\|\eta\|<2.3$. This is to ensure the tau is well within the acceptance of the silicon tracker.
    - A cut requiring $p_T > 20 GeV$.
    - A cut vetoing `Tau_decayMode =5, 6, 7`. These are "experimental 2-prong" decay modes.
    - The `VLoose`, `Tight`, Tight working points for the DeepTau discriminators: `Tau_idDeepTau2017v2p1VSe`, `Tau_idDeepTau2017v2p1VSmu`, `Tau_idDeepTau2017v2p1VSjet`
    - <https://twiki.cern.ch/CMS/TauIDRecommendationForRun2>
- Jets: 
    - A cut requiring $\|\eta\|<2.5$. We only consider jets within the tracker as we will be b-tagging these jets.
    - A cut requiring $p_T>20$.
    - An ID variable: `4&Jet_jetId`
    - <https://twiki.cern.ch/CMS/JetID13TeVRun2018>

The different triggers may require different kinematic cuts ($p_T, \eta$) depending on their design. Some triggers have different isolation requirements on the reconstructed objects. The trigger variable names (fortunately) describe the criteria on the reconstructed objects to be applied offline. The goal of this section is too see which of the two routes specific to your channel (trigger 1 or trigger 2) give the greatest signal efficiency.

To get an estimate of the number of expected events to be observed in data, you need to scale your mc events by a "cross section weight". This concept is highlighted [here](https://twiki.cern.ch/twiki/pub/CMS/SWGuideCMSDataAnalysisSchoolLPC2023ZTauTauXsec/xsexample.pdf) .
<!-- This link is not working -->

> ## Deliverable
> Deliverable for the end of the day: A table containing the signal efficiencies for each of your two trigger options, including the total number of events which passed your baseline and numerator selection. Scale these numbers by the appropriate cross section weight to produce a ballpark estimate for the number of events expected at 2018 luminosity.
{: .challenge}



{% include links.md %}

